<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AutoCaps Preview</title>
  <style>
    :root {
      --caption-font-size: 58px;
      --caption-zoom-duration: 0.3s;

      --highlight-blue:  #70e2ff;
      --highlight-yellow:#ffe83f;
      --highlight-green: #9fff5b;

      --caption-outline-color: #000000;
    }

    /* Adjust this path ONLY if your font file is different */
    @font-face {
      font-family: "TheBoldFont";
      src: url("D:/VSCode Projects/UIUXMAIN/AutoCapsAI/public/fonts/THEBOLDFONT-FREEVERSION.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      background: #05060a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .player-wrapper {
      position: relative;
      width: 80vw;
      max-width: 960px;
      aspect-ratio: 16 / 9;
      background: #000;
      overflow: hidden;
      border-radius: 12px;
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .captions-overlay {
      position: absolute;
      left: 50%;
      bottom: 10%;
      transform: translateX(-50%);
      width: 90%;
      pointer-events: none;
      text-align: center;
      text-transform: uppercase;
      font-size: var(--caption-font-size);
      font-family: "TheBoldFont", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.1;
    }

    .sentence {
      display: none;              /* only one group visible at a time */
      white-space: pre-wrap;
      transform-origin: center center;
    }

    .sentence.visible {
      display: inline-block;
    }

    .sentence.zoom-in {
      animation: sentence-zoom var(--caption-zoom-duration) ease-out;
    }

    @keyframes sentence-zoom {
      0%   { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

  .word {
  position: relative;
  display: inline-block;
  color: #ffffff;

  /* stronger, cleaner white glow + outline */
  text-shadow:
    0 0 2px var(--caption-outline-color),
    0 0 4px var(--caption-outline-color),
    0 0 6px rgba(0, 0, 0, 0.85),

    /* bright white glow */
    0 0 3px  #ffffffaa,
    0 0 6px #ffffffaa,
    0 0 12px #ffffffaa;
}


    .word + .word {
      margin-left: 0.14em;
    }

    .word.active {
      text-shadow:
        0 0 2px var(--caption-outline-color),
        0 0 4px var(--caption-outline-color),
        0 0 8px rgba(0, 0, 0, 0.95),
        0 0 6px currentColor,
        0 0 12px currentColor;
    }

    .word.active.blue   { color: var(--highlight-blue); }
    .word.active.yellow { color: var(--highlight-yellow); }
    .word.active.green  { color: var(--highlight-green); }
  </style>
</head>
<body>
  <div class="player-wrapper">
    <video id="video" controls crossorigin="anonymous">
      <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4" type="video/mp4" />
    </video>

    <div id="captions" class="captions-overlay"></div>
  </div>

  <script>
    const transcript = {
      text: "Welcome to AutoCaps AI, the ultimate tool for creators to generate engaging captions with dynamic animations and custom styles for every video project.",
      words: [
        { text: "Welcome",   start: 100,   end: 600,   confidence: 0.99, speaker: "A" },
        { text: "to",        start: 600,   end: 900,   confidence: 0.98, speaker: "A" },
        { text: "AutoCaps",  start: 900,   end: 1600,  confidence: 0.99, speaker: "A" },
        { text: "AI",        start: 1600,  end: 2000,  confidence: 0.95, speaker: "A" },
        { text: "the",       start: 2000,  end: 2300,  confidence: 0.98, speaker: "A" },
        { text: "ultimate",  start: 2300,  end: 3000,  confidence: 0.99, speaker: "A" },
        { text: "tool",      start: 3000,  end: 3500,  confidence: 0.97, speaker: "A" },
        { text: "for",       start: 3500,  end: 3800,  confidence: 0.98, speaker: "A" },
        { text: "creators",  start: 3800,  end: 4500,  confidence: 0.99, speaker: "A" },
        { text: "to",        start: 4500,  end: 4800,  confidence: 0.97, speaker: "A" },
        { text: "generate",  start: 4800,  end: 5400,  confidence: 0.98, speaker: "A" },
        { text: "engaging",  start: 5400,  end: 6000,  confidence: 0.99, speaker: "A" },
        { text: "captions",  start: 6000,  end: 6700,  confidence: 0.98, speaker: "A" },
        { text: "with",      start: 6700,  end: 7000,  confidence: 0.97, speaker: "A" },
        { text: "dynamic",   start: 7000,  end: 7700,  confidence: 0.99, speaker: "A" },
        { text: "animations",start: 7700,  end: 8500,  confidence: 0.95, speaker: "A" },
        { text: "and",       start: 8500,  end: 8800,  confidence: 0.98, speaker: "A" },
        { text: "custom",    start: 8800,  end: 9500,  confidence: 0.99, speaker: "A" },
        { text: "styles",    start: 9500,  end: 10200, confidence: 0.97, speaker: "A" },
        { text: "for",       start: 10200, end: 10500, confidence: 0.98, speaker: "A" },
        { text: "every",     start: 10500, end: 11000, confidence: 0.99, speaker: "A" },
        { text: "video",     start: 11000, end: 11500, confidence: 0.98, speaker: "A" },
        { text: "project",   start: 11500, end: 12000, confidence: 0.99, speaker: "A" }
      ],
      audio_duration: 12.0
    };

    // ms -> seconds
    transcript.words = transcript.words.map(w => ({
      ...w,
      startSec: w.start / 1000,
      endSec: w.end / 1000
    }));

    const MAX_WORDS_PER_SENTENCE = 4;  // <= 3â€“4 words per screen

    function buildWordGroups(words) {
      const groups = [];
      let i = 0;
      while (i < words.length) {
        const start = i;
        const end = Math.min(i + MAX_WORDS_PER_SENTENCE - 1, words.length - 1);
        groups.push({ startWordIndex: start, endWordIndex: end });
        i = end + 1;
      }
      return groups;
    }

    const sentences = buildWordGroups(transcript.words);

    const colorCycle = ["blue", "yellow", "green"];
    function getSentenceColor(sentenceIndex) {
      const group = Math.floor(sentenceIndex / 2) % colorCycle.length;
      return colorCycle[group];
    }

    const captionsEl = document.getElementById("captions");
    const wordElements = [];
    const sentenceElements = [];

    sentences.forEach((sentence, sIdx) => {
      const sentenceSpan = document.createElement("span");
      sentenceSpan.className = "sentence";

      const frag = document.createDocumentFragment();
      for (let i = sentence.startWordIndex; i <= sentence.endWordIndex; i++) {
        const w = transcript.words[i];
        const wordSpan = document.createElement("span");
        wordSpan.className = "word";
        wordSpan.dataset.index = i.toString();
        wordSpan.dataset.start = w.startSec.toString();
        wordSpan.dataset.end = w.endSec.toString();
        wordSpan.textContent = w.text;

        frag.appendChild(wordSpan);
        wordElements[i] = { el: wordSpan, sentenceIndex: sIdx };
      }

      sentenceSpan.appendChild(frag);
      captionsEl.appendChild(sentenceSpan);
      sentenceElements[sIdx] = sentenceSpan;
    });

    const video = document.getElementById("video");
    let lastActiveWordIndex = -1;
    let lastSentenceIndex = -1;

    function updateActiveWord(t) {
      let activeIndex = -1;

      for (let i = 0; i < transcript.words.length; i++) {
        const { startSec, endSec } = transcript.words[i];
        if (t >= startSec && t < endSec) {
          activeIndex = i;
          break;
        }
      }

      if (activeIndex === lastActiveWordIndex) return;

      if (lastActiveWordIndex !== -1 && wordElements[lastActiveWordIndex]) {
        const prev = wordElements[lastActiveWordIndex].el;
        prev.classList.remove("active", "blue", "yellow", "green");
      }

      if (activeIndex === -1) {
        if (lastSentenceIndex !== -1 && sentenceElements[lastSentenceIndex]) {
          sentenceElements[lastSentenceIndex].classList.remove("visible", "zoom-in");
        }
        lastActiveWordIndex = -1;
        return;
      }

      const { el: activeEl, sentenceIndex } = wordElements[activeIndex];

      const color = getSentenceColor(sentenceIndex);
      activeEl.classList.add("active", color);

      if (sentenceIndex !== lastSentenceIndex) {
        if (lastSentenceIndex !== -1 && sentenceElements[lastSentenceIndex]) {
          sentenceElements[lastSentenceIndex].classList.remove("visible", "zoom-in");
        }

        const sentenceEl = sentenceElements[sentenceIndex];
        sentenceEl.classList.add("visible");
        sentenceEl.classList.remove("zoom-in");
        void sentenceEl.offsetWidth; // restart animation
        sentenceEl.classList.add("zoom-in");

        lastSentenceIndex = sentenceIndex;
      }

      lastActiveWordIndex = activeIndex;
    }

    video.addEventListener("timeupdate", () => {
      updateActiveWord(video.currentTime);
    });

    video.addEventListener("seeked", () => {
      updateActiveWord(video.currentTime);
    });

    video.addEventListener("ended", () => {
      if (lastActiveWordIndex !== -1 && wordElements[lastActiveWordIndex]) {
        const prev = wordElements[lastActiveWordIndex].el;
        prev.classList.remove("active", "blue", "yellow", "green");
      }
      if (lastSentenceIndex !== -1 && sentenceElements[lastSentenceIndex]) {
        sentenceElements[lastSentenceIndex].classList.remove("visible", "zoom-in");
      }
      lastActiveWordIndex = -1;
      lastSentenceIndex = -1;
    });
  </script>
</body>
</html>
